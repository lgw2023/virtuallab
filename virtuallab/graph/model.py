"""Graph schema definitions for the VirtualLab knowledge graph.

This module defines the node and edge specifications used across the
application. The schema remains intentionally lightweight at this stage so
that subsequent iterations can extend the available attributes without
changing the public API surface.
"""
from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, Iterable, Mapping, MutableMapping, Optional


class NodeType(str, Enum):
    """Enumeration of supported node types in the VirtualLab graph."""

    PLAN = "Plan"
    SUBTASK = "Subtask"
    STEP = "Step"
    DATA = "Data"
    RESULT = "Result"
    NOTE = "Note"
    AGENT = "Agent"


class EdgeType(str, Enum):
    """Enumeration of supported edge types in the VirtualLab graph."""

    CONTAINS = "CONTAINS"
    USES_DATA = "USES_DATA"
    PRODUCES = "PRODUCES"
    DERIVES = "DERIVES"
    DEPENDS_ON = "DEPENDS_ON"
    CAUSED_BY = "CAUSED_BY"
    FOLLOWS = "FOLLOWS"
    ASSOCIATED_WITH = "ASSOCIATED_WITH"


@dataclass(slots=True)
class NodeSpec:
    """A typed node within the VirtualLab graph."""

    id: str
    type: NodeType
    attributes: MutableMapping[str, Any] = field(default_factory=dict)

    def update(self, values: Mapping[str, Any]) -> None:
        """Update node attributes with ``values`` in-place."""

        self.attributes.update(values)


@dataclass(slots=True)
class EdgeSpec:
    """A typed edge connecting two nodes in the VirtualLab graph."""

    source: str
    target: str
    type: EdgeType
    attributes: MutableMapping[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class GraphDelta:
    """Represents incremental updates applied to the underlying graph."""

    added_nodes: Iterable[NodeSpec] = field(default_factory=tuple)
    added_edges: Iterable[EdgeSpec] = field(default_factory=tuple)
    updated_nodes: Iterable[NodeSpec] = field(default_factory=tuple)


class GraphSchema:
    """Helper container describing required attributes for each node type."""

    DEFAULT_NODE_FIELDS: Dict[NodeType, Iterable[str]] = {
        NodeType.PLAN: ("name", "goal", "owner", "status"),
        NodeType.SUBTASK: ("plan_id", "name", "status", "priority"),
        NodeType.STEP: (
            "subtask_id",
            "name",
            "tool",
            "inputs",
            "status",
            "run_id",
        ),
        NodeType.DATA: ("payload_ref", "format", "source"),
        NodeType.RESULT: ("summary", "metrics", "produced_by_step"),
        NodeType.NOTE: ("content", "tags", "linked_to"),
        NodeType.AGENT: ("kind", "config"),
    }

    DEFAULT_EDGE_FIELDS: Dict[EdgeType, Iterable[str]] = {
        EdgeType.CONTAINS: tuple(),
        EdgeType.USES_DATA: ("role",),
        EdgeType.PRODUCES: ("quality",),
        EdgeType.DERIVES: ("method",),
        EdgeType.DEPENDS_ON: ("reason",),
        EdgeType.CAUSED_BY: ("evidence",),
        EdgeType.FOLLOWS: ("ts",),
        EdgeType.ASSOCIATED_WITH: ("score",),
    }

    @classmethod
    def required_fields_for(cls, node_type: NodeType) -> Iterable[str]:
        """Return the required attribute fields for ``node_type``."""

        return cls.DEFAULT_NODE_FIELDS.get(node_type, tuple())

    @classmethod
    def edge_fields_for(cls, edge_type: EdgeType) -> Iterable[str]:
        """Return the default attribute fields for ``edge_type``."""

        return cls.DEFAULT_EDGE_FIELDS.get(edge_type, tuple())


def coerce_node_payload(
    node_type: NodeType, attributes: Optional[Mapping[str, Any]] = None
) -> NodeSpec:
    """Create a :class:`NodeSpec` ensuring required fields exist.

    The function only performs shallow validation at this stage; a fuller
    validation pipeline will be implemented in later milestones.
    """

    if attributes is None:
        attributes = {}
    missing = [
        field for field in GraphSchema.required_fields_for(node_type) if field not in attributes
    ]
    if missing:
        raise ValueError(f"Missing required fields for {node_type}: {missing}")
    identifier = str(attributes.get("id")) if "id" in attributes else ""
    if not identifier:
        raise ValueError("Node identifier must be pre-generated by the caller.")
    attrs = dict(attributes)
    attrs.setdefault("labels", [])
    return NodeSpec(id=identifier, type=node_type, attributes=attrs)


def coerce_edge_payload(
    edge_type: EdgeType,
    source: str,
    target: str,
    attributes: Optional[Mapping[str, Any]] = None,
) -> EdgeSpec:
    """Create an :class:`EdgeSpec` ensuring default fields exist."""

    if attributes is None:
        attributes = {}
    attrs = dict(attributes)
    for field in GraphSchema.edge_fields_for(edge_type):
        attrs.setdefault(field, None)
    return EdgeSpec(source=source, target=target, type=edge_type, attributes=attrs)
